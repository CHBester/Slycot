!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module wrapper ! in 
    interface  ! in :wrapper
!
! routines whose wrapper has been hand adjusted
!
        subroutine sb02md(dico,hinv,uplo,scal,sort,n,a,lda,g,ldg,q,ldq,rcond,wr,wi,s,lds,u,ldu,iwork,dwork,ldwork,bwork,info) ! in :slycot:SB02MD.f
            character :: dico
            character :: hinv='D'
            character :: uplo='U'
            character :: scal='N'
            character :: sort='S'
            integer :: n
            double precision check(shape(a,1)==n),dimension(lda,*),depend(n) :: a
            integer intent(hide),check(lda>=n),depend(a,n) :: lda=shape(a,0)
            double precision check(shape(g,1)==n),dimension(ldg,*),depend(n) :: g
            integer intent(hide),check(ldg>=n),depend(g,n) :: ldg=shape(g,0)
            double precision intent(in,out=x,copy),check(shape(q,1)==n),dimension(ldq,*),depend(n) :: q
            integer intent(hide),check(ldq>=n),depend(q,n) :: ldq=shape(q,0)
            double precision intent(out),dimension(2*n,2*n),depend(n) :: u
            integer intent(hide),depend(u) :: ldu=shape(u,0)
            integer intent(out) :: info
            double precision intent(out):: rcond
            double precision intent(out),dimension(2*n),depend(n) :: wr
            double precision intent(out),dimension(2*n),depend(n) :: wi
            double precision intent(out),dimension(2*n,2*n),depend(n) :: s
            integer intent(hide),depend(s) :: lds=shape(s,0)
            integer intent(hide,cache),dimension(2*n),depend(n) :: iwork
            double precision intent(hide,cache),dimension(ldwork) :: dwork
            integer optional,check(ldwork>=max(3,6*n)),depend(n) :: ldwork=max(3,6*n)
            logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
        end subroutine sb02md
        subroutine sb03md(dico,job,fact,trana,n,c,ldc,a,lda,u,ldu,scale,sep,ferr,wr,wi,iwork,dwork,ldwork,info) ! in :new:SB03MD.f
            character :: dico
            character :: job='X'
            character :: fact='N'
            character :: trana='N'
            integer :: n
            double precision check(shape(a,1)==n),dimension(lda,*),depend(n) :: a
            integer intent(hide),depend(a) :: lda=shape(a,0)
            double precision dimension(ldu,*) :: u
            integer intent(hide),depend(u) :: ldu=shape(u,0)
            double precision intent(in,out=x,copy),dimension(ldc,*) :: c
            integer intent(hide),depend(c) :: ldc=shape(c,0)
            double precision intent(out) :: scale
            double precision intent(out) :: sep
            double precision intent(out) :: ferr
            double precision intent(out),dimension(n),depend(n) :: wr
            double precision intent(out),dimension(n),depend(n) :: wi
            integer intent(hide,cache),dimension(n*n),depend(n) :: iwork
            double precision intent(hide,cache),dimension(ldwork) :: dwork
            integer optional,check(ldwork>=max(2*n*n,3*n)),depend(n) :: ldwork=max(2*n*n,3*n)
            integer intent(out) :: info
        end subroutine sb03md
        subroutine ab08nd(equil,n,m,p,a,lda,b,ldb,c,ldc,d,ldd,nu,rank_bn,dinfz,nkror,nkrol,infz,kronr,kronl,af,ldaf,bf,ldbf,tol,iwork,dwork,ldwork,info) ! in :new:AB08ND.f
            character :: equil='N'
            integer :: n
            integer :: m
            integer :: p
            double precision check(shape(a,1)==n && shape(a,0)>=n),dimension(lda,*),depend(n) :: a
            integer intent(hide),depend(a) :: lda=shape(a,0)
            double precision check(shape(b,1)==m),dimension(ldb,*),depend(m) :: b
            integer intent(hide),depend(b) :: ldb=shape(b,0)
            double precision check(shape(c,1)==n && shape(b,0)>=p),dimension(ldc,*),depend(n) :: c
            integer intent(hide),depend(c) :: ldc=shape(c,0)
            double precision check(shape(d,1)==m && shape(d,0)>=m),dimension(ldd,*),depend(m) :: d
            integer intent(hide),depend(d) :: ldd=shape(d,0)
            integer intent(out) :: nu
            integer intent(out) :: rank_bn
            integer intent(out) :: dinfz
            integer intent(out) :: nkror
            integer intent(out) :: nkrol
            integer intent(out),dimension(n),depend(n) :: infz
            integer intent(out),dimension(max(n,m)+1),depend([n,m]) :: kronr
            integer intent(out),dimension(max(n,p)+1),depend([n,p]) :: kronl
            double precision intent(out),dimension(max(1,n+m),n+min(p,m)) :: af
            integer intent(hide),depend(af) :: ldaf=shape(af,0)
            double precision intent(out),dimension(max(1,n+p),n+m) :: bf
            integer intent(hide),depend(bf) :: ldbf=shape(bf,0)
            double precision :: tol=0.0
            integer intent(hide,cache),dimension(max(m,p)) :: iwork
            double precision intent(hide,cache),dimension(ldwork) :: dwork
            integer optional :: ldwork = n + 3*max(m,p)
            integer intent(out) :: info
        end subroutine ab08nd
        subroutine mc01td(dico,dp,p,stable,nz,dwork,iwarn,info) ! in :new:MC01TD.f
            character :: dico
            integer intent(in,out),check(dp>0) :: dp
            double precision intent(in),check(shape(p,0)==dp+1),dimension(dp+1),depend(dp) :: p
            logical intent(out) :: stable
            integer intent(out) :: nz
            double precision intent(cache,hide),dimension(2*dp+2),depend(dp) :: dwork
            integer intent(out) :: iwarn
            integer intent(out) :: info
        end subroutine mc01td
        subroutine sb02od(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
            character :: dico
            character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
            character intent(hide) :: fact = 'N' ! idem
            character :: uplo = 'U'
            character :: jobl = 'Z'
            character :: sort = 'S'
            integer check(n>0) :: n
            integer check(m>0) :: m
            integer intent(hide) :: p=0 ! this is not needed as fact = 'N' 
            double precision check(shape(a,1)==n),dimension(lda,*),depend(n) :: a
            integer intent(hide),check(lda>=n),depend(a) :: lda=shape(a,0)
            double precision check(shape(b,1)==m),dimension(ldb,*),depend(m) :: b
            integer intent(hide),check(ldb>=n),depend(b) :: ldb=shape(b,0)
            double precision check(shape(q,1)==n),dimension(ldq,*),depend(n) :: q
            integer intent(hide),check(ldq>=n),depend(q) :: ldq=shape(q,0)
            double precision check(shape(r,1)==m),dimension(ldr,*),depend(m) :: r
            integer intent(hide),check(ldr>=m),depend(r) :: ldr=shape(r,0)
            double precision check(shape(l,1)==m),dimension(ldl,m),depend(m) :: l
            integer intent(hide),check(ldl>=n),depend(l) :: ldl=shape(l,0)
            double precision intent(out) :: rcond
            double precision intent(out),dimension(n,n) :: x
            integer intent(hide),depend(x) :: ldx=shape(x,0)
            double precision intent(out),dimension(2*n) :: alfar
            double precision intent(out),dimension(2*n) :: alfai
            double precision intent(out),dimension(2*n) :: beta
            double precision intent(out),dimension(2*n+m,2*n) :: s
            integer intent(hide),depend(s) :: lds=shape(s,0)
            double precision intent(out),dimension(2*n+m+1,2*n) :: t
            integer intent(hide),depend(t) :: ldt=shape(t,0)
            double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
            integer intent(hide),depend(u) :: ldu=shape(u,0)
            double precision :: tol=0
            integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
            double precision intent(hide,cache),dimension(ldwork) :: dwork
            integer optional :: ldwork=16*n+3*m+16
            logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
            integer intent(out) :: info
        end subroutine sb02od
        ! the following defaults to leri = 'L' 
        subroutine tb03ad_l(leri,equil,n,m,p,a,lda,b,ldb,c,ldc,d,ldd,nr,index_bn,pcoeff,ldpco1,ldpco2,qcoeff,ldqco1,ldqco2,vcoeff,ldvco1,ldvco2,tol,iwork,dwork,ldwork,info) ! in :new:TB03AD.f
            fortranname tb03ad
            character intent(hide) :: leri = 'L'
            character :: equil = 'N'
            integer check(n>0) :: n
            integer check(m>0) :: m
            integer check(p>0) :: p
            double precision intent(in,out=a_min),check(shape(a,1)==n),dimension(lda,*),depend(n) :: a
            integer intent(hide),check(lda>=n),depend(a) :: lda=shape(a,0)
            double precision intent(in,out=b_min),check(shape(b,1)==max(m,p)),dimension(ldb,*),depend(m,p) :: b
            integer intent(hide),check(ldb>=n),depend(b) :: ldb=shape(b,0)
            double precision intent(in,out=c_min),check(shape(c,1)==n),dimension(ldc,*),depend(n) :: c
            integer intent(hide),check(ldc>=max(m,p)),depend(c) :: ldc=shape(c,0)
            double precision check(shape(d,1)==max(m,p)),dimension(ldd,*),depend(m,p) :: d
            integer intent(hide),check(ldd>=max(m,p)),depend(d) :: ldd=shape(d,0)
            integer intent(out) :: nr
            integer intent(out),dimension(p) :: index_bn
            double precision intent(out),dimension(p,p,n+1) :: pcoeff
            integer intent(hide),depend(pcoeff) :: ldpco1=shape(pcoeff,0)
            integer intent(hide),depend(pcoeff) :: ldpco2=shape(pcoeff,1)
            double precision intent(out),dimension(p,m,n+1) :: qcoeff
            integer intent(hide),depend(qcoeff) :: ldqco1=shape(qcoeff,0)
            integer intent(hide),depend(qcoeff) :: ldqco2=shape(qcoeff,1)
            double precision intent(out),dimension(p,n,n+1) :: vcoeff
            integer intent(hide),depend(vcoeff) :: ldvco1=shape(vcoeff,0)
            integer intent(hide),depend(vcoeff) :: ldvco2=shape(vcoeff,1)
            double precision :: tol = 0
            integer intent(hide,cache),dimension(n+max(m,p)) :: iwork
            double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
            integer :: ldwork = max( 2*n + 3*max(m,p), p*(p+2)) 
            integer intent(out) :: info
        end subroutine tb03ad
        ! the following defaults to leri = 'R'
        subroutine tb03ad_r(leri,equil,n,m,p,a,lda,b,ldb,c,ldc,d,ldd,nr,index_bn,pcoeff,ldpco1,ldpco2,qcoeff,ldqco1,ldqco2,vcoeff,ldvco1,ldvco2,tol,iwork,dwork,ldwork,info) ! in :new:TB03AD.f
            fortranname tb03ad
            character intent(hide) :: leri = 'R'
            character :: equil = 'N'
            integer check(n>0) :: n
            integer check(m>0) :: m
            integer check(p>0) :: p
            double precision intent(in,out=a_min),check(shape(a,1)==n),dimension(lda,*),depend(n) :: a
            integer intent(hide),check(lda>=n),depend(a) :: lda=shape(a,0)
            double precision intent(in,out=b_min),check(shape(b,1)==max(m,p)),dimension(ldb,*),depend(m,p) :: b
            integer intent(hide),check(ldb>=n),depend(b) :: ldb=shape(b,0)
            double precision intent(in,out=c_min),check(shape(c,1)==n),dimension(ldc,*),depend(n) :: c
            integer intent(hide),check(ldc>=max(m,p)),depend(c) :: ldc=shape(c,0)
            double precision check(shape(d,1)==max(m,p)),dimension(ldd,*),depend(m,p) :: d
            integer intent(hide),check(ldd>=max(m,p)),depend(d) :: ldd=shape(d,0)
            integer intent(out) :: nr
            integer intent(out),dimension(m) :: index_bn
            double precision intent(out),dimension(m,m,n+1) :: pcoeff
            integer intent(hide),depend(pcoeff) :: ldpco1=shape(pcoeff,0)
            integer intent(hide),depend(pcoeff) :: ldpco2=shape(pcoeff,1)
            double precision intent(out),dimension(max(m,p),max(m,p),n+1) :: qcoeff
            integer intent(hide),depend(qcoeff) :: ldqco1=shape(qcoeff,0)
            integer intent(hide),depend(qcoeff) :: ldqco2=shape(qcoeff,1)
            double precision intent(out),dimension(m,n,n+1) :: vcoeff
            integer intent(hide),depend(vcoeff) :: ldvco1=shape(vcoeff,0)
            integer intent(hide),depend(vcoeff) :: ldvco2=shape(vcoeff,1)
            double precision :: tol = 0
            integer intent(hide,cache),dimension(n+max(m,p)) :: iwork
            double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
            integer :: ldwork = max( 2*n + 3*max(m,p), m*(m+2)) 
            integer intent(out) :: info
        end subroutine tb03ad
!
! routines whose wrapper was auto generated
!
        subroutine sb02mu(dico,hinv,uplo,n,a,lda,g,ldg,q,ldq,s,lds,iwork,dwork,ldwork,info) ! in :slycot:SB02MU.f
            character :: dico
            character :: hinv
            character :: uplo
            integer :: n
            double precision dimension(lda,*) :: a
            integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
            double precision dimension(ldg,*) :: g
            integer optional,check(shape(g,0)==ldg),depend(g) :: ldg=shape(g,0)
            double precision dimension(ldq,*) :: q
            integer optional,check(shape(q,0)==ldq),depend(q) :: ldq=shape(q,0)
            double precision dimension(lds,*) :: s
            integer optional,check(shape(s,0)==lds),depend(s) :: lds=shape(s,0)
            integer dimension(*) :: iwork
            double precision dimension(*) :: dwork
            integer :: ldwork
            integer :: info
        end subroutine sb02mu 
        subroutine sb03mv(ltran,lupper,t,ldt,b,ldb,scale,x,ldx,xnorm,info) ! in :new:SB03MV.f
            logical :: ltran
            logical :: lupper
            double precision dimension(ldt,*) :: t
            integer optional,check(shape(t,0)==ldt),depend(t) :: ldt=shape(t,0)
            double precision dimension(ldb,*) :: b
            integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
            double precision :: scale
            double precision dimension(ldx,*) :: x
            integer optional,check(shape(x,0)==ldx),depend(x) :: ldx=shape(x,0)
            double precision :: xnorm
            integer :: info
        end subroutine sb03mv
        subroutine sb03mw(ltran,lupper,t,ldt,b,ldb,scale,x,ldx,xnorm,info) ! in :new:SB03MW.f
            logical :: ltran
            logical :: lupper
            double precision dimension(ldt,*) :: t
            integer optional,check(shape(t,0)==ldt),depend(t) :: ldt=shape(t,0)
            double precision dimension(ldb,*) :: b
            integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
            double precision :: scale
            double precision dimension(ldx,*) :: x
            integer optional,check(shape(x,0)==ldx),depend(x) :: ldx=shape(x,0)
            double precision :: xnorm
            integer :: info
        end subroutine sb03mw
        subroutine sb03mx(trana,n,a,lda,c,ldc,scale,dwork,info) ! in :new:SB03MX.f
            character :: trana
            integer :: n
            double precision dimension(lda,*) :: a
            integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
            double precision dimension(ldc,*) :: c
            integer optional,check(shape(c,0)==ldc),depend(c) :: ldc=shape(c,0)
            double precision :: scale
            double precision dimension(*) :: dwork
            integer :: info
        end subroutine sb03mx
        subroutine sb03my(trana,n,a,lda,c,ldc,scale,info) ! in :new:SB03MY.f
            character :: trana
            integer :: n
            double precision dimension(lda,*) :: a
            integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
            double precision dimension(ldc,*) :: c
            integer optional,check(shape(c,0)==ldc),depend(c) :: ldc=shape(c,0)
            double precision :: scale
            integer :: info
        end subroutine sb03my
        subroutine sb04px(ltranl,ltranr,isgn,n1,n2,tl,ldtl,tr,ldtr,b,ldb,scale,x,ldx,xnorm,info) ! in :new:SB04PX.f
            logical :: ltranl
            logical :: ltranr
            integer :: isgn
            integer :: n1
            integer :: n2
            double precision dimension(ldtl,*) :: tl
            integer optional,check(shape(tl,0)==ldtl),depend(tl) :: ldtl=shape(tl,0)
            double precision dimension(ldtr,*) :: tr
            integer optional,check(shape(tr,0)==ldtr),depend(tr) :: ldtr=shape(tr,0)
            double precision dimension(ldb,*) :: b
            integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
            double precision :: scale
            double precision dimension(ldx,*) :: x
            integer optional,check(shape(x,0)==ldx),depend(x) :: ldx=shape(x,0)
            double precision :: xnorm
            integer :: info
        end subroutine sb04px
        subroutine mb01rd(uplo,trans,m,n,alpha,beta,r,ldr,a,lda,x,ldx,dwork,ldwork,info) ! in :new:MB01RD.f
            character :: uplo
            character :: trans
            integer :: m
            integer :: n
            double precision :: alpha
            double precision :: beta
            double precision dimension(ldr,*) :: r
            integer optional,check(shape(r,0)==ldr),depend(r) :: ldr=shape(r,0)
            double precision dimension(lda,*) :: a
            integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
            double precision dimension(ldx,*) :: x
            integer optional,check(shape(x,0)==ldx),depend(x) :: ldx=shape(x,0)
            double precision dimension(*) :: dwork
            integer :: ldwork
            integer :: info
         end subroutine mb01rd
    end interface 
end python module slycot
