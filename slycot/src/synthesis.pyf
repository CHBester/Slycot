subroutine sb01bd(dico,n,m,np,alpha,a,lda,b,ldb,wr,wi,nfp,nap,nup,f,ldf,z,ldz,tol,dwork,ldwork,iwarn,info) ! in SB01BD.f
    character :: dico
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    integer required,check(np>=0 && np<=n),depend(n) :: np
    double precision :: alpha
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(np),depend(np) :: wr
    double precision intent(in,out,copy),dimension(np),depend(np) :: wi
    integer intent(out) :: nfp
    integer intent(out) :: nap
    integer intent(out) :: nup
    double precision intent(out),dimension(m,n) :: f
    integer intent(hide),depend(f) :: ldf=shape(f,0)
    double precision intent(out),dimension(n,n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    double precision :: tol = 0
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer :: ldwork = max(5*n,2*n+5*m)+1
    integer intent(out) :: iwarn
    integer intent(out) :: info
end subroutine sb01bd
subroutine sb02md(dico,hinv,uplo,scal,sort,n,a,lda,g,ldg,q,ldq,rcond,wr,wi,s,lds,u,ldu,iwork,dwork,ldwork,bwork,info) ! in :slycot:SB02MD.f
	fortranname sb02md
	character :: dico
	character :: hinv='D'
	character :: uplo='U'
	character :: scal='N'
	character :: sort='S'
	integer check(n>0):: n
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,n),depend(n) :: g
	integer intent(hide),depend(g) :: ldg=shape(g,0)
	double precision intent(in,out),dimension(n,n),depend(n) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision intent(out),dimension(2*n,2*n),depend(n) :: u
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	integer intent(out) :: info
	double precision intent(out):: rcond
	double precision intent(out),dimension(2*n),depend(n) :: wr
	double precision intent(out),dimension(2*n),depend(n) :: wi
	double precision intent(out),dimension(2*n,2*n),depend(n) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	integer intent(hide,cache),dimension(2*n),depend(n) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional,check(ldwork>=max(3,6*n)),depend(n) :: ldwork=max(3,6*n)
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
end subroutine sb02md
subroutine sb03md(dico,job,fact,trana,n,c,ldc,a,lda,u,ldu,scale,sep,ferr,wr,wi,iwork,dwork,ldwork,info) ! in :new:SB03MD.f
	fortranname sb03md
	character :: dico
	character :: job='X'
	character :: fact='N'
	character :: trana='N'
	integer check(n>0) :: n
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,n),depend(n) :: u
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision intent(in,out,copy),dimension(n,n),depend(n) :: c
	integer intent(hide),depend(c) :: ldc=shape(c,0)
	double precision intent(out) :: scale
	double precision intent(out) :: sep
	double precision intent(out) :: ferr
	double precision intent(out),dimension(n),depend(n) :: wr
	double precision intent(out),dimension(n),depend(n) :: wi
	integer intent(hide,cache),dimension(n*n),depend(n) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional,check(ldwork>=max(2*n*n,3*n)),depend(n) :: ldwork=max(2*n*n,3*n)
	integer intent(out) :: info
end subroutine sb03md
!
! wrappers for sb02od
!
subroutine sb02od_n(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'N'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer intent(hide) :: p=0 ! this is not needed as fact = 'N' 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(n,n),depend(n) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(m,m),depend(m) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m+1,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_n
subroutine sb02od_c(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'C'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer required,check(p>0) :: p 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(p,n),depend(n,p) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(m,m),depend(m) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m+1,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_c
subroutine sb02od_d(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'D'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer required,check(p>0) :: p 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(n,n),depend(n) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(p,m),depend(m,p) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m+1,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_d
subroutine sb02od_b(dico,jobb,fact,uplo,jobl,sort,n,m,p,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,rcond,x,ldx,alfar,alfai,beta,s,lds,t,ldt,u,ldu,tol,iwork,dwork,ldwork,bwork,info) ! in :new:SB02OD.f
	fortranname sb02od
	character :: dico
	character intent(hide) :: jobb = 'B' ! fixed for simplicity reasons, for 'G' use sb02md instead
	character intent(hide) :: fact = 'B'
	character :: uplo = 'U'
	character :: jobl = 'Z'
	character :: sort = 'S'
	integer required,check(n>0) :: n
	integer required,check(m>0) :: m
	integer required,check(p>0) :: p 
	double precision dimension(n,n),depend(n) :: a
	integer intent(hide),depend(a) :: lda=shape(a,0)
	double precision dimension(n,m),depend(m,n) :: b
	integer intent(hide),depend(b) :: ldb=shape(b,0)
	double precision dimension(p,n),depend(n,p) :: q
	integer intent(hide),depend(q) :: ldq=shape(q,0)
	double precision dimension(p,m),depend(m,p) :: r
	integer intent(hide),depend(r) :: ldr=shape(r,0)
	double precision dimension(n,m),depend(m,n) :: l
	integer intent(hide),depend(l) :: ldl=shape(l,0)
	double precision intent(out) :: rcond
	double precision intent(out),dimension(n,n) :: x
	integer intent(hide),depend(x) :: ldx=shape(x,0)
	double precision intent(out),dimension(2*n) :: alfar
	double precision intent(out),dimension(2*n) :: alfai
	double precision intent(out),dimension(2*n) :: beta
	double precision intent(out),dimension(2*n+m,2*n) :: s
	integer intent(hide),depend(s) :: lds=shape(s,0)
	double precision intent(out),dimension(2*n+m+1,2*n) :: t
	integer intent(hide),depend(t) :: ldt=shape(t,0)
	double precision intent(hide),dimension(2*n,2*n) :: u ! not needed as jobb = 'B'
	integer intent(hide),depend(u) :: ldu=shape(u,0)
	double precision :: tol=0
	integer intent(hide,cache),dimension(max(2*n,m)),depend(n,m) :: iwork
	double precision intent(hide,cache),dimension(ldwork) :: dwork
	integer optional :: ldwork=16*n+3*m+16
	logical intent(hide,cache),dimension(2*n),depend(n) :: bwork
	integer intent(out) :: info
end subroutine sb02od_b
!
! routines for sb02mt
!
subroutine sb02mt_n(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'Z'
    character intent(hide) :: fact = 'N'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(out),dimension(1,1) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out),dimension(1,1) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(out),dimension(1,1) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(m),depend(m) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer :: ldwork = max(3,n)*m+2
    integer intent(out) :: info
end subroutine sb02mt_n
subroutine sb02mt_c(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'Z'
    character intent(hide) :: fact = 'C'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(out),dimension(1,1) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out),dimension(1,1) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(out),dimension(1,1) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(1) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer intent(hide) :: ldwork = 1
    integer intent(out) :: info
end subroutine sb02mt_c
subroutine sb02mt_nl(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'N'
    character intent(hide) :: fact = 'N'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(m),depend(m) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer :: ldwork = max(3,n)*m+2
    integer intent(out) :: info
end subroutine sb02mt_nl
subroutine sb02mt_cl(jobg,jobl,fact,uplo,n,m,a,lda,b,ldb,q,ldq,r,ldr,l,ldl,ipiv,oufact,g,ldg,iwork,dwork,ldwork,info) ! in SB02MT.f
    fortranname sb02mt
    character intent(hide) :: jobg = 'G' ! fixed for simplicity
    character intent(hide) :: jobl = 'N'
    character intent(hide) :: fact = 'C'
    character :: uplo = 'U'
    integer required,check(n>=0) :: n
    integer required,check(m>=0) :: m
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(in,out,copy),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(m,m),depend(m) :: r
    integer intent(hide),depend(r) :: ldr=shape(r,0)
    double precision intent(in,out,copy),dimension(n,m),depend(n,m) :: l
    integer intent(hide),depend(l) :: ldl=shape(l,0)
    integer intent(out),dimension(1) :: ipiv
    integer intent(out) :: oufact
    double precision intent(out),dimension(n,n),depend(n) :: g
    integer intent(hide),depend(g) :: ldg=shape(g,0)
    integer intent(hide,cache),dimension(m) :: iwork
    double precision intent(hide,cache),dimension(ldwork),depend(ldwork) :: dwork
    integer intent(hide) :: ldwork = 1
    integer intent(out) :: info
end subroutine sb02mt_cl
